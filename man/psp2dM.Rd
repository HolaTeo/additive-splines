% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/psp2dM.R
\name{psp2dM}
\alias{psp2dM}
\title{Two-dimensional penalized signal regression using P-splines.}
\usage{
psp2dM(y, M, p1, p2, M.type = "stacked", M1.index = NULL,
  M2.index = NULL, Pars, ridge.adj = 1e-06, M.pred = M,
  y.predicted = NULL, x.lab = "X1", y.lab = "X2", z.lab = "A.hat",
  coef.plot = T, image.plot = T, se.bands = T, family = "gaussian",
  link = "default", m.binomial = NULL, wts = NULL, r.gamma = NULL,
  int = F)
}
\arguments{
\item{y}{a response vector of length \code{m}, usually continuous, binary/bimomial or counts.}

\item{M}{The image regressors, which are either "stacked" or "unfolded",
with dimensions (m x p1) x p2 (i.e m matrices each of p1xp2) or
length p1xp2, respectively.}

\item{p1}{the row dimension of the image.}

\item{p2}{the column dimension of the image.}

\item{M.type}{"stacked" or "unfolded"}

\item{M1.index}{an index of length \code{p1} for rows of regressor matrix; default is simple sequence.}

\item{M2.index}{an index of length \code{p2} for columns of regressor matrix.}

\item{Pars}{a matrix with 2 rows, each with P-spline parameters:
\code{min max nseg deg lambda pdeg}, for row and columns.}

\item{ridge.adj}{A ridge penalty tuning parameter (usually set to small value, e.g. 1e-8 to stabilize estimation).}

\item{M.pred}{(stacked) \code{qp1 x p2} signal inputs  or (unfolded) \code{q x (p1 x p2)} signal
inputs for \code{q} new predictions.}

\item{y.predicted}{a vector of responses from a cv data set (assoc. with \code{M.pred}).}

\item{coef.plot}{set to T or F to display coefficient perspective surface.}

\item{image.plot}{set to T or F to display coefficient image surface.}

\item{se.bands}{set to T or F to produce se surfaces for plots.}

\item{family}{the response distribution, e.g.
\code{"gaussian", "binomial", "poisson", "Gamma"} distribution. Quotes are needed.}

\item{link}{link function (\code{identity, log, sqrt, logit, probit, cloglog, loglog, recipical}). Quotes are needed.}

\item{m.binomial}{a vector of binomial trials having length(y). Default is 1 vector for binomial, NULL otherwise.}

\item{wts}{the weight vector of \code{length(y)}. Deault is 1.}

\item{r.gamma}{a vector of gamma shape parameters. Default is 1 vector for gamma, NULL otherwise.}

\item{int}{set to T or F to include intercept term in linear predictor.}

\item{min(max)}{A scalar for the min(max) along x or y.}

\item{x.lab(y.lab, z.lab)}{"character" labels for estimated coefficient surface}

\item{nseg}{the number of evenly spaced segments between min and max.}

\item{bdeg}{a number for the degree of the basis, usually 1, 2, or 3.}

\item{pord}{the number for the order of the difference penalty, usually 1, 2, or 3.}

\item{lambda}{the (positive) tuning parameter for the penalty.}
}
\value{
\item{coef}{a vector of length \code{(Pars[1,3]+Pars[1,4])*(Pars[1,3]+Pars[1,4])}
of (unfolded) estimated P-spline coefficients for tensor surface.}
\item{summary.predicted}{inverse link prediction vectors, and +/- twice se bands.}
\item{deviance}{deviance of fit.}
\item{eff.df}{the approximate effective dimension of fit.}
\item{aic}{AIC}
\item{df.resid}{approx. df resid.}
\item{summary.beta}{a matrix of dimension \code{px3}, containing beta, and +/- twice se bands for beta.}
\item{cv}{leave-one-out standard error prediction (\code{normal, identity}).}
\item{cv.predicted}{standard error prediction for \code{y.predict} (normal, identity).}
\item{Pars}{nseg, bdeg, pord, lambda design parameters}
\item{Dispersion.parm}{estimate of dispersion, Dev/df.resid.}
\item{summary.predicted}{inverse link prediction vectors, and +/- twice se bands.}
\item{eta.predicted}{estimated linear predictor of \code{length(y)}.}
\item{press.mu}{leave-one-out prediction of mean (\code{normal, identity}).}
\item{bin.percent.correct}{percent correct classification based on 0.5 cut-off (\code{binomial}).}
}
\description{
psp2dM is used to regress a (glm) response onto a two-dimensional
 signal or image, with aniosotripic penalization of
tensor product B-splines.
}
\examples{
library(fields)
library(JOPS)
# Get the data
x0 = Sugar[,4:4000]
x0=x0-apply(x0,1,mean) #center Signal
y=as.vector(Sugar[,3]) #Response is Ash
# Inputs for two-dimensional signal regression
nseg=c(7,37)
pord=c(3,3)
min.=c(230,275)
max.=c(340,560)
M1.index=rev(c(340,325, 305,290,255,240,230))
M2.index=seq(from=275, to=560, by=.5)
p1=length(M1.index)
p2=length(M2.index)
int     <- T   # intercept in model
opt.lam=c(8858.6679, 428.1332) #Found via svcm
Pars.opt=rbind(c(min.[1],max.[1],nseg[1],3,opt.lam[1],pord[1]),
              c(min.[2],max.[2],nseg[2],3,opt.lam[2],pord[2]))
fit=fit.opt=psp2dM(y, x0, p1, p2, "unfolded", M1.index, M2.index, Pars.opt,
                  coef.plot=F, se=F, int=int, ridge.adj=1e-6)
par(mfrow = c(1, 1))
set_window()
adj=25 # Creating mask of 1s and NAs for contriant
mask.=1*outer(fit$M2grid-adj, fit$M1grid,'>')
mask.[mask.==0]=NA
A.hatm=matrix(fit$bgrid\%*\%fit$coef[-1],length(fit$M1grid),
              length(fit$M2grid), byrow=T)
image.plot(fit$M2grid, fit$M1grid, t(A.hatm)*mask.,
          col = terrain.colors(100), ylab = 'Excitation (nm)',
          xlab = 'Emission (nm)')
}
\references{
Marx, B.D. and Eilers, P.H.C. (2005).
Multidimensional penalized signal regression, Technometrics, 47: 13-22.
}
\author{
Paul Eilers and Brian Marx
}
